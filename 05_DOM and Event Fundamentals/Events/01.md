In javascript as it is a sequnential language that each code runs sequentially and same goes with the event also but there are some exception in it.

And also if we want to write some event/activity on a element then it is not a good practice to directly inject it to HTML because when the application scales then in that case it will cause problem.

So the `better approach is`  select that element by using DOM and then apply event/activity on it.


Suppose if we want to apply `onclick` to a image of owl then there are two way :


```html
//This is not a better way to do that
<img id='owl' src = 'owl.jpg' onclick="alert('This is a owl')">
```

```js
const myOwl = document.querySelector('owl');
myOwl.onclick = function(){
  alert('This is my owl');
}
```

Fact 😁😁 is the above is right but it doesn't comes with features as event listeners comes with so using `event listeners using will be a good choice`

```js
document.querySelector('#owl').addEventListener('click', function(){
   alert('This is my owl');
}, false);
```

>[!NOTE]
>Important event we must read about are type ,timestamp ,defaultPrevent ,target ,toElement ,srcElement , currentTarget ,clientX ,clientY ,screenX ,screenY
>And in keyboard we have access to various key like altkey ,ctrlkey ,shiftkey ,keycode



### Event Propagation

Event Propagation in JS is a mechanism that controls how events flow through DOM. However if element's aren't nested and we don't need separate events for each, event propagation isn't a concern. `Each element can have it's own handlers and an event on one won't affect the others.` 

*However even in such cases understanding event propagation can be useful for managing interactions and optimizing performance in larger applications*


Some of the important use case of event propagation are :

1. *Event Delegation* : This is where we bind a single event listener to a parent element in order to avoid having to add event listeners to multiple child elements

 2. *Optimisation* : By doing event delegation instead of attaching separate event listeners to each individual element we can attach them to a parent element 

3. *Complex UI Interaction* : It allow us for complex UI interaction ex  when we have a button inside a drop down menu and we want different things to happen depending upon whether button or drop down menu is clicked

4. *Stopping Unwanted actions* : By calling event.stopPropagation() we can stop certain events from bubbling up the DOM tree which can be useful when we don't parents to be notified of events on a child elements



In summary _**Event propagation allows you to manage and control how events are handled in a group or collection of elements on a webpage.**_



>[!NOTE]
>So, when we set an event listener on a parent element, it will also catch events that are triggered on its children. This is because of event bubbling.



consider the below html :

```
  <ul id="images>
   <li><img id="japan src="japan.jpg"></li>
   <li><img id="owl" src="owl.jpg"></li>
   <li><img id="fountain" src="fountain.jpg"></li>
   <li><img id="chai" src="chai.jpg"></li>
   <li><img id="code" src="code.jpg"></li>
   </ul>
```

And suppose we are writing the below code

```js
document.querySelector('#images').addEventListener('click', function(){
   console.log('clicked inside ul');
})

document.querySelector('#owl').addEventListener('click' ,function(){
   console.log('owl clicked');
})
```

By above code we are targeting the same element because since `#owl is also inside the ul` so the code targeting the `ul` will also  be get executed but interesting thing is that  *in which order does both the code will get executed*

here firstly `owl clicked` will get executed and then `clicked inside ul` and this is because of event bubbling that means *event will go from bottom to top* and if we want to stop this we can use **event.stopPropagation()** where the event would bubble up

If we want to remove a element from DOM then there are two ways to do that

1. `Using .remove() method` :

```js
document.querySelector(`#id`).addEventListener('click' ,function(){
    let removeIt = event.target;
    removeIt.remove();

     //2nd way
     removeIt.parentNode.removeChild(removeIt);
})
```

here in the first way it is directly removing the target but in 2nd way it is getting the parent of the target and then among various children of parent it is using `removeChild()` and then removing the target

Both are correct way of removing element from DOM

```js
document.querySelector(`#id`).addEventListener('click' ,function(event){
    let removeIt = event.target;
    console.log(event.tagName);
        
})
```

Here `.tagName` will give the element tag which cause the click event that either it is an h1 tag or list item or something else